### 一条查询语句在mysql中是如何执行的
#### 连接器
客户端首先从连接器那里获取连接，校验账号密码，完成之后获取用户权限，之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这意味着，即使该用户的权限被更改，也不会影响到已经存在的连接，只有新建的连接才会使用新的用户权限。

#### 查询缓存
获取连接之后，会判断当前SQL语句在Mysql中是否存在缓存，如果命中缓存，直接返回缓存的结果。否则进入后面的阶段，执行完之后，会将结果存入查询缓存中。
但是大多数情况下，不建议使用查询缓存。因为一旦表有更新，那么该表的所有缓存将会被清除。Mysql在8.0版本直接移除了查询缓存的功能。在此之前，可以使用“按需使用”的方式，显示添加缓存。可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定。比如`mysql> select SQL_CACHE * from T where ID=10；`

#### 分析器
进行语法，词法分析。如果有错误会返回错误。

#### 优化器
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。提高语句的执行效率。

#### 执行器
开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。


### redolog（重做日志） && binlog（归档日志）
#### redo log（innoDB 特有的日志）
如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者用到了 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。具体来说就是，当一条记录需要更新时，InnoDB 引擎就会先把记录写到 redo log 里面（持久化到日志文件里），并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
redolog的大小是固定的，一旦redolog写满了，这时候不能再执行新的更新。mysql会将redolog里的日志抽取一部分写入磁盘并删除这部分日志，保证下次还可以继续往redolog写日志。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。

#### binlog（mysql server层的通用的日志）
server层的通用日志，可以被任意存储引擎调用。

#### 这2种日志的不同点
这两种日志有以下三点不同：
1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

#### 两阶段提交（保证redolog和binlog的一致性）
假设更新ID=2的语句，流程如下：
1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

### 事务
事务是为了保证一系列操作要么成功要么失败，比如给某人转账，包括为别人账户增加余额，给自己账号减少余额。在mysql中事务操作是在引擎层实现的，你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是
MyISAM 被 InnoDB 取代的重要原因之一。
事务的4个特性：ACID，即原子性，一致性，隔离性，持久性
#### 隔离性与隔离级别
当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我
们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：`读未提交（readuncommitted）`、`读提交（read committed）`、`可重复读（repeatable read）`和`串行化（serializable ）`。
下面我逐一为你解释：
- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。

### 索引
索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。