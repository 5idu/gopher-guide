### 使用List实现
- 基于lpush,rpush,lpop,rpop实现队列的生产-消费功能
- 缺点
    - 做消费者确认ACK麻烦，不能保证消费者消费消息后是否成功处理的问题（宕机或处理异常等），通常需要维护一个Pending列表，保证消息处理确认。
    - 不能做广播模式，如pub/sub，消息发布/订阅模型
    - 不能重复消费，一旦消费就会被删除
    - 不支持分组消费

### pub/sub订阅发布模式
SUBSCRIBE，用于订阅信道，PUBLISH，向信道发送消息，UNSUBSCRIBE，取消订阅。
此模式允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由对应的消费组消费。
- 优点
    - 典型的广播模式，一个消息可以发布到多个消费者
    - 多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息
    - 消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息

- 缺点
    - 没有ACK机制
    - 消息一旦发布，不能接收。换句话就是发布时若客户端不在线，则消息丢失，不能寻回
    - 不能保证每个消费者接收的时间是一致的
    - 若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时
可见，Pub/Sub 模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。

### 基于ZSet的实现
Sortes Set(有序列表)，是一个set，保证内部value的唯一性，另一方面它可以给每个value赋予一个score，代表这个value的排序权重。内部实现是`跳跃表`。

有序集合的方案是在自己确定消息顺序时比较常用，使用集合成员的Score来作为消息ID，保证顺序，还可以保证消息ID的单调递增。通常可以使用时间戳+序号的方案。确保了消息ID的单调递增，利用SortedSet依据Score排序的特征，就可以制作一个有序的消息队列了。
缺点：不允许重复消息（因为是集合），同时消息ID确定有错误会导致消息的顺序出错。

### 基于Stream实现